<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title> Function Scoping </title>
<script type="text/javascript" src="open_parent.js"></script>
<link rel="stylesheet" type="text/css" href="pkc.css">
<link rel="stylesheet" type="text/css" href="stylesheet.css">
<meta name="description" content="Configurer's Reference Guide for Singleview Convergent Billing 9.1 ">
<script language="javascript" type="text/javascript" src="dhtml_toc.js"></script>
<script language="JavaScript">
<!--

document.onkeydown = checkChangePage;
function checkChangePage(e)
{
   if (!e) var e = window.event;
   // Don't put the following into the first page
   if ((e.ctrlKey && (e.keyCode == 37))) {
      // Ctrl-Left Arrow was pressed or Page up key pressed at the top of the page
      document.location.href = "51598.htm";
   } else
   // Don't put the following into the late page for a document
   if ((e.ctrlKey && (e.keyCode == 39))) {
      // Ctrl-Right Arrow was pressed or Page down key pressed and at the bottom of the page
      document.location.href = "28068.htm";
   }
}

function MM_swapImgRestore() { //v3.0
  var i,x,a=document.MM_sr; for(i=0;a&&i<a.length&&(x=a[i])&&x.oSrc;i++) x.src=x.oSrc;
}

function MM_preloadImages() { //v3.0
  var d=document; if(d.images){ if(!d.MM_p) d.MM_p=new Array();
    var i,j=d.MM_p.length,a=MM_preloadImages.arguments; for(i=0; i<a.length; i++)
    if (a[i].indexOf("#")!=0){ d.MM_p[j]=new Image; d.MM_p[j++].src=a[i];}}
}

function MM_findObj(n, d) { //v4.0
  var p,i,x;  if(!d) d=document; if((p=n.indexOf("?"))>0&&parent.frames.length) {
    d=parent.frames[n.substring(p+1)].document; n=n.substring(0,p);}
  if(!(x=d[n])&&d.all) x=d.all[n]; for (i=0;!x&&i<d.forms.length;i++) x=d.forms[i][n];
  for(i=0;!x&&d.layers&&i<d.layers.length;i++) x=MM_findObj(n,d.layers[i].document);
  if(!x && document.getElementById) x=document.getElementById(n); return x;
}

function MM_swapImage() { //v3.0
  var i,j=0,x,a=MM_swapImage.arguments; document.MM_sr=new Array; for(i=0;i<(a.length-2);i+=3)
   if ((x=MM_findObj(a[i]))!=null){document.MM_sr[j++]=x; if(!x.oSrc) x.oSrc=x.src; x.src=a[i+2];}
}

function printpage()
{
	window.print();
}
//-->
</script>
</head>
<body onload="loadParent();MM_preloadImages('left_down.gif','right_down.gif','index_down.gif','contents_down.gif','search_down.gif','print_down.gif');if (isTOCLoaded()) {expand('27907');expand('45618');highlight('59016')}">
<div class="menubar">  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr valign="middle">      <td width="70">        <a href="51598.htm" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('left','','left_down.gif',1)">        <img name="left" border="0" src="left_up.gif" width="26" height="26" alt="Previous topic" title="Previous topic"></a>        <a href="28068.htm" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('right','','right_down.gif',1)">        <img name="right" border="0" src="right_up.gif" width="26" height="26" alt="Next topic" title="Next topic"></a></td>        <td class="bodytext">Configurer's Reference Guide for Singleview Convergent Billing 9.1 </td>        <td width="40">        <div align="center">        <a href="javascript:printpage();" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('print','','print_down.gif',1)">        <img name="print" border="0" src="print_up.gif" width="26" height="26" alt="Print this page" title="Print this page"></a>      </div>       </td></tr>  </table></div><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td width="100%">
<h3 class="heading3">Function Scoping</h3>
</td><td class="feedback"><p><a href="mailto:ipoint@csgi.com?subject=Feedback on Topic 'Function Scoping' (59016)"><img border=0 src="email.png" alt="Provide feedback on this topic"></a></p></td></tr></table><p class="bodytext">Function scoping enables a group of EVS functions, evaluated in the same transaction and process, to defer all in-transaction expression evaluation and post-commit expression queuing until the end of the scope before transaction commit. In-transaction expression evaluation and post-commit queuing is deferred until all calls are made successfully.</p>
<p class="bodytext">Function scoping queues all post-commit expressions as a single queued message rather than individual messages. Entity variable initialisation is improved if the variables are initialised to the correct values by a previous EVS function as part of the scope.</p>
<p class="bodytext">EVS functions called between the <span class="unixoutputc"><a id="h70416" class="jump" title="EVS_ScopeBegin&amp;()" href="58495.htm" target="_self">EVS_ScopeBegin&amp;()</a></span>, <span class="unixoutputc"><a id="h75144" class="jump" title="EVS_ScopeAbort&amp;()" href="75129.htm" target="_self">EVS_ScopeAbort&amp;()</a></span>, and <span class="unixoutputc"><a id="h70417" class="jump" title="EVS_ScopeEnd&amp;()" href="58492.htm" target="_self">EVS_ScopeEnd&amp;()</a></span> functions are considered to be part of the scope.</p>
<p class="bodytext">EVS scope can be nested. In this case, deferred expressions are not processed until the final <span class="unixoutputc">EVS_ScopeEnd&amp;()</span> is called. Every <span class="unixoutputc">EVS_ScopeBegin&amp;()</span> must be matched with appropriate <span class="unixoutputc">EVS_ScopeEnd&amp;()</span> and <span class="unixoutputc">EVS_ScopeAbort&amp;()</span> calls. Care must also be taken in nested scope situations to handle errors and raise the appropriate error for the next scope level error handling to catch.</p>
<p class="bodytext">The scoping process is:</p>
<ol class="listnumber"><li class="listnumber">Begin transaction (implicit).</li><li class="listnumber">Call <span class="unixoutputc">EVS_ScopeBegin&amp;()</span>.</li><li class="listnumber">Run base product row validation.</li><li class="listnumber">Run base product pre-commit validation.</li><li class="listnumber">Call <span class="unixoutputc"><a id="h75151" class="jump" title="biProductInsert&amp;()" href="13018.htm" target="_self">biProductInsert&amp;()</a></span> to insert the base product.</li><li class="listnumber">Run companion product row validation.</li><li class="listnumber">Run companion product pre-commit validation.</li><li class="listnumber">Call <span class="unixoutputc">biProductInsert&amp;()</span> to insert the companion product.</li><li class="listnumber">If the above steps following the call to <span class="unixoutputc">EVS_ScopeBegin&amp;()</span> are:<ul class="listbullet2"><li class="listbullet2">Successful, call <span class="unixoutputc">EVS_ScopeEnd&amp;()</span> to end EVS scope.</li><li class="listbullet2">Unsuccessful, call <span class="unixoutputc">EVS_ScopeAbort&amp;()</span> to abort EVS scope.</li></ul></li><li class="listnumber">Run base product in-transaction expressions.</li><li class="listnumber">Run companion product in-transaction expressions.</li><li class="listnumber">Queue base product and companion product post-commit expressions as a single message.</li><li class="listnumber">End transaction (implicit).</li><li class="listnumber">Run base product and companion product post-commit expressions.</li></ol>
<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td width="100%"><a name="o40691"></a><h3 class="heading3">Encryption and Masking</h3>
</td><td class="feedback"><p><a href="mailto:ipoint@csgi.com?subject=Feedback on Topic 'Encryption and Masking' (40691)"><img border=0 src="email.png" alt="Provide feedback on this topic"></a></p></td></tr></table><p class="bodytext">EVS supports handling of data that is encrypted or masked.  When data is transferred to or from the database by EVS, a check is performed on each field value configured for encryption or masking to determine if the data should be decrypted, masked, unmasked, or encrypted, based on the:</p>
<ul class="listbullet"><li class="listbullet">Field's encryption and masking settings</li><li class="listbullet">Data's encryption status</li><li class="listbullet">User's security settings.</li></ul><p class="bodytext">EVS calls the tresec to perform the encryption, decryption, and masking of the data, as appropriate for the user's security privileges.  These actions are performed when the data is transferred to or from the database to avoid pre- or post-entity validation logic being run on encrypted data, and to prevent false updates to the database.</p>
<table width="100%" class="notestyle"><tr><td><p class="note">Note:</p><p class="note">EVS performs security checks before the tresec is called.  This prevents security errors in the tresec.</p></td></tr></table>
<p class="bodytext">For more information about encryption, masking, and user security group privileges, refer to the <span class="referrals">Security and Auditing Configuration Guide for Singleview</span>. </p>
<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td width="100%"><a name="o27914"></a><h3 class="heading3">EVS Data Typing</h3>
</td><td class="feedback"><p><a href="mailto:ipoint@csgi.com?subject=Feedback on Topic 'EVS Data Typing' (27914)"><img border=0 src="email.png" alt="Provide feedback on this topic"></a></p></td></tr></table><p class="bodytext">EVS is strongly typed, although several different typing models can be selected.  The data typing model is selected using the <span class="unixoutputc">DATA_TYPING</span> attribute in the <span class="unixoutputc">EVS</span> configuration item and is applied globally in the environment.  It is not possible to use different typing models in different situations within the same environment.</p>
<p class="bodytext">A key is the name that refers to a specific value supplied to an EVS function call.  Keys are case-sensitive.  The key for a value is either the corresponding hash key for hash-based functions, or the corresponding element in the names array for array-based functions.  </p>
<p class="bodytext">EVS recognises two different types of keys: the <span class="fieldname">column name key</span>, and the <span class="fieldname">integration key</span>.  The column name key is the name of the database column that corresponds to the value (for example, <span class="unixoutputc">CUSTOMER_NODE_ID</span> or <span class="unixoutputc">NODE_NAME</span>).  Column name keys are always specified in upper case.</p>
<p class="bodytext">The integration key is a configurable value associated with an attribute type associated with the corresponding database field.  If defined, the interface label is used as the integration key; otherwise the display label is used.  EVS allows the integration key to be overridden by a value in the <span class="unixoutputc">EVS_ATTRIBUTE_TYPE_KEY</span> table to avoid any problems that may be introduced by localisation of an implementation into a different language.</p>
<p class="bodytext">Values are the data items applied to the various fields on an entity.  Values can be specified as either internal or external forms, depending on the key and typing model used.  The internal form is the same as the value stored in the database, in both data type and format.  For example, the <span class="unixoutputc">GENERAL_1</span> field always contains a string.  If the <span class="unixoutputc">GENERAL_1</span> field is being used to store an integer code, the internal form for this field is the string representation of that integer code.</p>
<p class="bodytext">External forms are dependent on the attribute type associated with the field.  The external form is equivalent to the value displayed on the corresponding client form.  The data type must match the data type specified in the attribute type.  For example, an integer code that is eventually stored in a string field such as <span class="unixoutputc">GENERAL_1</span> is the integer value in external forms.  </p>
<p class="bodytext">Normalised list fields allow the external form to be specified as the string abbreviation for the corresponding code; for example, a field that indicates the market region of a customer.  To specify a market region of 'LA County', the corresponding code is '3001', and the external form can be specified as either the integer value, '3001', or the string value 'LA County'.</p>

<table class="cautionstyle" width="100%"><tr><td><p class="caution">Caution:</p><ul class="cautionlistbullet"><li class="cautionlistbullet">Setting <span class="unixoutputc">DATA_TYPING</span> to Traditional or Weak is deprecated and likely to be de-supported in a future Singleview release.</li><li class="cautionlistbullet">The following features are supported only when <span class="unixoutputc">DATA_TYPING</span> is set to Enhanced:<ul class="cautionlistbullet2"><li class="cautionlistbullet2">External definitions </li><li class="cautionlistbullet2">Interface templates and interface definitions </li><li class="cautionlistbullet2">Entitlements </li><li class="cautionlistbullet2">Displaying and editing derived attribute tables using Business &amp; Administration Studio or Configuration Studio</li><li class="cautionlistbullet2">Convergent Billing's <span class="formname">Product Instance Detail</span> form </li><li class="cautionlistbullet2">Composite Business Functions (CBFs)</li><li class="cautionlistbullet2">Customer Management.</li></td></tr></table></ul></li></ul><p class="bodytext"><span class="unixoutputc">DATA_TYPING</span> can be set to one of the following values:</p>
<ul class="listbullet"><li class="listbullet">Enhanced (default)<p class="listcontinue">Allows applications to use either column name keys or integration keys.  When the column name key is used, the value must be specified on an internal form.  When the integration key is used, the value must be specified on an external form.  No other combinations are allowed, ensuring that a given key must always know the value type.</p>
</li><li class="listbullet">Traditional<p class="listcontinue">Only allows the use of key-value pairs compatible with using '<span class="unixoutputc">bi</span>' functions directly.  Only column name keys are allowed and data must be specified only on an internal form.  Column name keys can be used to ensure that the data is compatible with direct '<span class="unixoutputc">bi</span>' functions calls if required.</p>
</li><li class="listbullet">Weak<p class="listcontinue">Only allows the use of column name keys; however, values must be specified on an external form.  With weak typing, it is not possible to determine the required data type for a given key based on name alone.  For example, one customer type may use <span class="unixoutputc">GENERAL_5</span> to hold a normalised integer value, whereas another customer type may use it to hold a date value.  The weak typing model does not create any problems, and weak typing is often preferred to provide data in external forms, without having to publish a much larger list of key names.</p>
</li></ul>
<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td width="100%"><a name="o50543"></a><h3 class="heading3">Configurable Keys</h3>
</td><td class="feedback"><p><a href="mailto:ipoint@csgi.com?subject=Feedback on Topic 'Configurable Keys' (50543)"><img border=0 src="email.png" alt="Provide feedback on this topic"></a></p></td></tr></table><p class="bodytext">To support integration with external systems, the EVS permits identification of entity instances by a hash map of key fields.  Fetch, insert, update, and delete functions provide interfaces that accept the <span class="unixoutputc">Keys?{}</span> parameter.</p>
<p class="bodytext">The sets of key fields that identify an entity instance can be configured in its entity validation.  The configuration is made by specification of a pair of key field functions that control key validation and entity lookup.  The validation function defines the valid keys.  The entity lookup function determines a set of primary IDs for a matching entity, based on a valid set of keys.</p>
<p class="bodytext">If no key field functions are configured for an entity, key-based EVS functions use the <span class="unixoutputc"><a id="h50360" class="jump" title="fEVS_ValidateDefaultKeys&amp;()" href="58477.htm" target="_self">fEVS_ValidateDefaultKeys&amp;()</a></span> and <span class="unixoutputc"><a id="h50546" class="jump" title="fEVS_LookupDefaultKeys?[]()" href="59496.htm" target="_self">fEVS_LookupDefaultKeys?[]()</a></span> default functions to determine their entity instance.</p>

<table width="100%" class="notestyle"><tr><td><p class="note">Note:</p><ul class="notelistbullet"><li class="notelistbullet">Custom key field functions are required to maintain return behaviour that is identical to the default functions. </li><li class="notelistbullet">If key field functions are specified in an entity validation, all other entity validations using the same validation table must specify the same functions, or have no key field functions specified.</li></td></tr></table></ul>
<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td width="100%"><a name="o59168"></a><h3 class="heading3">Fetching Normalised Fields</h3>
</td><td class="feedback"><p><a href="mailto:ipoint@csgi.com?subject=Feedback on Topic 'Fetching Normalised Fields' (59168)"><img border=0 src="email.png" alt="Provide feedback on this topic"></a></p></td></tr></table><p class="bodytext">The EVS fetch APIs denormalise the values of fetched fields specified by attribute type interface or display label, regardless of whether the attribute type has been configured to be denormalised or not.  To return a field's normalised value, specify the field name with the data type EPM character of the attribute type appended to the end of the field label.</p>
<p class="bodytext">For example, to fetch the denormalised field:</p>
<pre class="unixoutputp">        var lKeys?{} := hash(['NODE_NAME'], ['Rowan Atkinson']);</pre>
<pre class="unixoutputp">        var lFieldNames$[] := ['Invoice Cycle'];</pre>
<pre class="unixoutputp">        return fEV_CustomerFetch?{}(lKeys?{}, lFieldNames$[]);</pre>
<p class="bodytext"> </p>
<p class="bodytext">This returns <span class="unixoutputc">{ Invoice Cycle =&gt; EVS Bill Run 1 }</span></p>
<p class="bodytext">To fetch the normalised field:</p>
<pre class="unixoutputp">        var lKeys?{} := hash(['NODE_NAME'], ['Rowan Atkinson']);</pre>
<pre class="unixoutputp">        var lFieldNames$[] := ['Invoice Cycle&amp;'];</pre>
<pre class="unixoutputp">        return fEV_CustomerFetch?{}(lKeys?{}, lFieldNames$[]);</pre>
<p class="bodytext">&nbsp;</p>
<p class="bodytext">This returns <span class="unixoutputc">{ Invoice Cycle =&gt; 878517 }</span> </p>
<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td width="100%"><a name="o64678"></a><h3 class="heading3">Derived Non-stored Attribute Types</h3>
</td><td class="feedback"><p><a href="mailto:ipoint@csgi.com?subject=Feedback on Topic 'Derived Non-stored Attribute Types' (64678)"><img border=0 src="email.png" alt="Provide feedback on this topic"></a></p></td></tr></table><p class="bodytext">Derived non-stored attribute types are used to send or receive data from EVS when the data is not associated with a database column but derived from one or more other data elements (see the <span class="referrals">Configuration Fundamentals Guide for Singleview Convergent Billing</span>).</p>
<p class="bodytext">The attribute type can be configured to return an array of references to other Convergent Billing entities. The returned array can be: </p>
<ul class="listbullet"><li class="listbullet">Integers with each element referencing a Convergent Billing entity</li><li class="listbullet">Hashes where each element represents the column names as keys of the related Convergent Billing entity. </li></ul><p class="bodytext">If the SQL-based attribute type is defined as an unknown array, the data returned from the EVS contains column names as keys, and data as rows. </p>
<table width="100%" class="notestyle"><tr><td><p class="note">Note:</p><p class="note">Only non-stored output attribute types can be configured to return an array of IDs.</p></td></tr></table>
<p class="bodytext">A fetch operation example is:</p>
<pre class="unixinputp">    var lperson_id&amp;;    var lvals?[];    fEV_PersonFetchById&amp;(lperson_id&amp;, current_date(), ['OFFICIAL_NAME', 'PERSON_STATUS_CODE'], vals?[]);    return  vals?[];</pre>
<p class="bodytext">&nbsp;</p>
<p class="bodytext">Results are:</p>
<pre class="unixinputp">    [{OFFICIAL_NAME =&gt; row1, PERSON_STATUS_CODE =&gt; 1}, {OFFICIAL_NAME =&gt; row2, PERSON_STATUS_CODE =&gt; 2}]</pre>
<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td width="100%"><a name="o71840"></a><h3 class="heading3">Multi-Tenancy</h3>
</td><td class="feedback"><p><a href="mailto:ipoint@csgi.com?subject=Feedback on Topic 'Multi-Tenancy' (71840)"><img border=0 src="email.png" alt="Provide feedback on this topic"></a></p></td></tr></table><p class="bodytext">The EVS interface supports the use of tenanted reference types when executed in a Singleview multi-tenant environment.</p>
<p class="bodytext">During calls to EVS functions, the reference codes available for a tenanted reference type are restricted to those belonging the calling operator's tenant.&nbsp; It is not possible to insert or update a reference code belonging to another tenant into a field. &nbsp;Nor is it possible to fetch the abbreviation or code label for a reference type field if it has been populated with another tenant's reference code.</p>
<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td width="100%"><a name="o27915"></a><h3 class="heading3">Null Values</h3>
</td><td class="feedback"><p><a href="mailto:ipoint@csgi.com?subject=Feedback on Topic 'Null Values' (27915)"><img border=0 src="email.png" alt="Provide feedback on this topic"></a></p></td></tr></table><p class="bodytext">NULL value for an element is indicated by passing the key with a corresponding undefined value in the hash or arrays.</p>
<p class="bodytext">Convergent Billing is required to pass empty elements (that is, elements with null/undefined values) for only those fields for which the value is explicitly set to 'NULL' in the user supplied data.  This is especially important for updates, where the application may be required to set a non-null value to a null value.</p>
<p class="bodytext">When EVS does not want to pass any value for an entity field, it can choose not to pass the corresponding element through the hash.</p>
<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td width="100%"><a name="o33136"></a><h3 class="heading3">EVS Cache</h3>
</td><td class="feedback"><p><a href="mailto:ipoint@csgi.com?subject=Feedback on Topic 'EVS Cache' (33136)"><img border=0 src="email.png" alt="Provide feedback on this topic"></a></p></td></tr></table><p class="bodytext">EVS and Convergent Billing processes optimise processing by using caches.  EVS and Convergent Billing caches are independent and can contain the same reference type.  </p>
<p class="bodytext">Because EVS maintains the EVS cache independently of Convergent Billing caches, a reference type purge in EVS is not automatically reflected in Convergent Billing caches.  Similarly, a reference type purge in Convergent Billing is not automatically reflected in the EVS cache.  These scenarios can create inconsistencies.</p>
<p class="bodytext">These inconsistencies can be avoided.  When a reference type is updated in Convergent Billing, the <span class="unixoutputc">biReferenceTypePurge&amp;()</span> function is called to notify Convergent Billing processes to purge the reference type.</p>
<p class="bodytext">EVS uses the <span class="unixoutputc">fEVS_ReferenceTypePurge&amp;()</span> function to purge a reference type from the EVS cache.  <span class="unixoutputc"><a id="h33138" class="jump" title="fEVS_ReferenceTypePurge&amp;()" href="33137.htm" target="_self">fEVS_ReferenceTypePurge&amp;()</a></span> also calls <span class="unixoutputc">biReferenceTypePurge&amp;()</span> to purge the reference type from Convergent Billing process caches.  </p>
<p class="bodytext">To ensure that the EVS cache is purged when a reference type is purged in Convergent Billing), <span class="unixoutputc">biReferenceTypePurge&amp;()</span> can be aliased with <span class="unixoutputc">fEVS_ReferenceTypePurge&amp;()</span>.  The alias causes <span class="unixoutputc">fEVS_ReferenceTypePurge&amp;()</span> to be called in place of <span class="unixoutputc">biReferenceTypePurge&amp;()</span>, resulting in the reference type being purged from the EVS cache.  </p>
<p class="bodytext"><span class="unixoutputc">fEVS_ReferenceTypePurge&amp;()</span> calls <span class="unixoutputc">biReferenceTypePurge&amp;()</span> (without causing infinite recursion), purging the reference type from the Convergent Billing caches.</p>
<p class="bodytext">Function aliases are created using function roles. For more information, refer to the <span class="referrals">System Configuration Guide for Singleview Convergent Billing</span>.</p>
<p class="bodytext">The following figure displays an example of a function alias using a function role.</p>
<p class="bodytext">&nbsp;</p>
<p class="bodytext"><img src="33190_fnrolealias.png" alt="Function Role Definition Form (Alias example)" height="400" width="658" vspace="2" hspace="2" align="bottom" border="0"></p>
<p class="caption">Creation of a Function Alias</p>
<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td width="100%"><a name="o33198"></a><h3 class="heading3">API Model</h3>
</td><td class="feedback"><p><a href="mailto:ipoint@csgi.com?subject=Feedback on Topic 'API Model' (33198)"><img border=0 src="email.png" alt="Provide feedback on this topic"></a></p></td></tr></table><p class="bodytext">EVS functions make entity validation performed within the Convergent Billing client available to processes, to avoid creating more than one copy of validation rules.</p>
<p class="bodytext">Entity manipulation functions (for example, <span class="unixoutputc">fEV_AdjustmentInsert&amp;()</span>) in the EVS API are remote TRE functions and execute within a TRE server.  The functions mimic the environment of the client by creating the client-defined entity validation variables, which enables execution of entity validation expressions that reference the variables.</p>
<table class="cautionstyle" width="100%"><tr><td><p class="caution">Caution:</p><p class="caution">Do not call EVS functions in entity validation expressions.  When an EVS function is called by a process, the processing includes execution of the entity validation expressions.  If an entity validation expression includes a call to an EVS function, the called function is executed within EVS; that is, EVS is calling EVS.  This may cause previously-initiated entity validation variables to be corrupted if the called function overwrites them.</p></td></tr></table>
<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td width="100%"><a name="o45725"></a><h3 class="heading3">Nested Function Calls</h3>
</td><td class="feedback"><p><a href="mailto:ipoint@csgi.com?subject=Feedback on Topic 'Nested Function Calls' (45725)"><img border=0 src="email.png" alt="Provide feedback on this topic"></a></p></td></tr></table><p class="bodytext">EVS functions are re-entrant.  EVS supports entity validation configuration calling EVS and CBF functions, both directly and indirectly. </p>


<br><div class="menubar">  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr valign="middle">      <td width="70">        <a href="51598.htm" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('left','','left_down.gif',1)">        <img name="left" border="0" src="left_up.gif" width="26" height="26" alt="Previous topic" title="Previous topic"></a>        <a href="28068.htm" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('right','','right_down.gif',1)">        <img name="right" border="0" src="right_up.gif" width="26" height="26" alt="Next topic" title="Next topic"></a></td>        <td class="bodytext">Configurer's Reference Guide for Singleview Convergent Billing 9.1 </td>        <td width="40">        <div align="center">        <a href="javascript:printpage();" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('print','','print_down.gif',1)">        <img name="print" border="0" src="print_up.gif" width="26" height="26" alt="Print this page" title="Print this page"></a>      </div>       </td></tr>  </table></div></body>
</html>


